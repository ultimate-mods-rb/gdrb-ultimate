#define TRACK_END_FRAME (1920)
#define TRACK_PANEL_HANDLERS (
   (in_intro_outro_shot FALSE)
   (enter
      {$this update_track_speeds}
      {game add_sink $this}
      {$this set_showing
         {'||'
            $skip_intro
            {gamemode in_mode drum_trainer}
            {! {gamemode in_mode practice}}
         }
      }
      #ifdef HX_WII
      {rnd frames_buffered 2}
      #endif
   )
   (exit
      {if {exists guitar_effects}
         {do
            {guitar_effects set_showing FALSE}
         }
      }
      {if {exists bass_effects}
         {do
            {bass_effects set_showing FALSE}
         }
      }
      #ifdef HX_WII
      {rnd frames_buffered 1}
      #endif
      {game remove_sink $this}
   )
   (unison_hit)
   (unison_miss)
   (set_track_out)
   (set_track_in)
   (animate_track ($start $end $period $units))
   (animate_track_out)
   (animate_track_out_fast)
   (animate_track_in_fast)
   (finish_load
      {$this iterate TrackDir $dir
         {with $dir
            {unless $kickbounce
               {set [kick_drummer_trig] {new EventTrigger empty}}
            }
            {foreach_int $i 0 5
               {{new PropAnim {sprintf "gem_bak%d.anim" $i}} copy {sprintf "gem_mash%d.anim" $i} 0}
            }
            {foreach_int $i 0 5 {do
               ($wid {sprintf "gem_mash%d.wid" $i})
               ($color {eval_var {sprint gtrsm {+ $i 1}}})
               {clear_array $wid meshes}
               {$wid insert (meshes 0) {sprintf "gem_mash%d.mesh" $color}}
               {{sprintf "gem_mash%d.anim" $i} copy {sprintf "gem_bak%d.anim" $color} 0}
            }}
            {foreach_int $i 1 5
               {{new PropAnim {sprintf "drum_bak%d.anim" $i}} copy {sprintf "drum_mash%d.anim" $i} 0}
               {{new PropAnim {sprintf "drum_bak%d_BRE.anim" $i}} copy {sprintf "drum_mash%d_BRE.anim" $i} 0}
            }
            {foreach_int $i 1 5 {do
               ($wid {sprintf "drum_mash%d.wid" $i})
               ($color
                  {switch {eval_var {sprint drms $i}}
                     (0 4)
                     {eval_var {sprint drms $i}}
                  }
               )
               {clear_array $wid meshes}
               {$wid insert (meshes 0) {sprintf "drum_mash%d.mesh" $color}}
               {{sprintf "drum_mash%d.anim" $i} copy {sprintf "drum_bak%d.anim" $color} 0}
               {{sprintf "drum_mash%d_BRE.anim" $i} copy {sprintf "drum_bak%d_BRE.anim" $color} 0}
            }}
         }
      }
      {if {!= $gems rb2} {do
         ($gems_dir {new RndDir gems_dir})
         {switch $gems
            #include ../ulti/track/gems/gems_scripting.dta
         }
      }}
      {if {!= $smashers rb2} {do
         ($smashers_dir {new RndDir smashers_dir})
         {switch $smashers
            #include ../ulti/track/smashers/smashers_scripting.dta
         }
      }}
      {$this set_showing FALSE}
      {$this set_track_out}
   )
   (intro_start
      {$this update_track_speeds}
      {$this track_reset}
      {$this set_showing {! {gamemode has (disable_achivements)}}}
      {$this set_track_in}
   )
   (intro_skip
      {$this update_track_speeds}
      {$this track_reset}
      {$this set_showing {! {gamemode has (disable_achivements)}}}
      {$this set_track_out}
      {if {&& {exists gamemode} {! {gamemode get is_tutorial}}}
         {$this play_intro}
      }
   )
   (configure_optimizations
      ; the wii port does this diffrently but it seemed to be doing
      ; a bunch of totally useless fucked up stuff that would always return 0
      ; if my assessment was wrong pls fix!
      {do
         ($total_players 0)
         {if {exists beatmatch}
            {beatmatch foreach_active_player $player
               {'++' $total_players}
            }
         }
         #ifdef HX_PS3
         {set $optimization_lod
            {if_else {> $total_players 2}
               1
               0
            }
         }
         #else
         {set $optimization_lod 0}
         #endif
         {set $track_LOD $optimization_lod}
      }
   )
   (on_reset
      {beatmatch foreach_active_player $m
         {$m on_new_track}
         {{$m track} init {$m track}}
      }
      {{$this loaded_dir} reset}
      {$this configure_optimizations}
   )
   (on_extend
      {$this do_stuff}
      {$this update_track_speeds}
      {$this play_intro}
      {if {&& {exists gamemode} {gamemode get play_track_intro_sfx}}
         {synth play track_beg.cue}
      }
   )
   (update_track_speeds
      {if_else {&& {exists beatmatch} {beatmatch active_player 0}}
         {do
            ($average_difficulty 0)
            ($num_tracks 0)
            {beatmatch foreach_active_player $player
               {unless {|| {== {$player instrument} vocals} {$player is_net}}
                  {+= $average_difficulty {$player difficulty}}
                  {+= $num_tracks 1}
               }
            }
            {if {> $num_tracks 0}
               {/= $average_difficulty $num_tracks}
               {/= $average_difficulty kDifficultyExpert}
            }
            {beatmatch foreach_active_player $player
               {unless {== {$player instrument} vocals} {do
                  ($obj {get_dir_from_player $player})
                  ($diff_view_time
                     {cond
                        ($syncdifspeeds 1.2)
                        ($indvtrkspeeds {elem (2.4 2.0 1.6 1.2) {$player difficulty}})
                        (TRUE {+ 2.4 {* $average_difficulty -1.2}})
                     }
                  )
                  ($ts
                     {if_else {profile_mgr get_hyperspeed}
                        {+ {eval_var {sprint {$player instrument} "_trackspeed"}} 0.5}
                        {eval_var {sprint {$player instrument} "_trackspeed"}}
                     }
                  )
                  ($view_time {/ $diff_view_time $ts})
                  {print {sprint $obj " " $diff_view_time " " $ts " " $hwss " " $view_time}}
                  {$obj set y_per_second {/ {$obj get top_y} $view_time}}
               }}
            }
         }
         {print "can't update track speeds now!"}
      }
   )
   (do_stuff
      {print "doing stuff"}
      {if {&& {exists gems_dir} {gems_dir exists animate.trig}}
         {{gems_dir find animate.trig} trigger}
      }
      {beatmatch set_kick_autoplay
         {&&
            $autokick
            {! {gamemode get online_play_required}}
         }
      }
      {beatmatch foreach_active_player $player ;handle adding the appropriate callbacks to each player
         {do
            ($obj {sprint {$player track} "_track_callback"})
            {if {exists $obj} {delete $obj}}
            {new Object $obj}
            {$obj set_type track_callback}
            {$obj init $player}
         }
      }
      {print "done stuff"}
   )
)
{new TrackPanel
   coop_track_panel
   (file "track/trackpanel.milo")
   TRACK_PANEL_HANDLERS
}
{new TrackPanel
   h2h_track_panel
   (file "track/trackpanel_h2h.milo")
   TRACK_PANEL_HANDLERS
}
{func get_track_panel
   {gamemode get track_panel}
}
{set $playback_file ""}